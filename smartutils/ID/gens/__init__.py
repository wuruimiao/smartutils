"""
# 各种不依赖存储的算法的对比

1.数据长度、2.数据结构、3.寿命、4.实例限制、5.并发限制、6.原理

Snowflake
1. 64位整型（long型，19位十进制数字）
2. 1位符号位(一定正数) | 41位时间戳(毫秒) | 10位机器ID | 12位序列号
3. 约可用69年，起始时间自定义
4. 支持1024台机器
5. 单节点单毫秒最大生成4096个ID，超过时需等待下一毫秒
6.

Sonyflake （没有符号位，依赖语言原生有uint64/大数）
1. 64位整型（long型，19位十进制数字）
2. 39位时间戳(单位10毫秒) | 8位序列号 | 16位机器ID
3. 约可用174年，起始时间自定义
4. 支持65536台机器
5. 每10毫秒可生成256个ID，超过时需等待下一个10毫秒
6. 起始时间默认2014-09-01T00:00:00+09:00（日本标准时间，JST），适合单时区

# TODO：补充不同provider的实现
ULID
1. 128位二进制，一般以26位Base32字符串表示
2. 48位时间戳(毫秒) | 80位随机数（策略实现不同）
    default: 随机
    microsecond: 10位微妙，70位随机，更有序，更难碰撞；但受限环境微妙精度、安全场景
    monotonic: 加threading.Lock，同一timestamp严格递增
3. 约可用8947年
4. 无
5. 单毫秒内可生成2^80（约1.2e24）个唯一ID
6. 起始时间1970年1月1日

KSUID
1. 160位二进制，27位Base62字符串（或32字节二进制）
2. 32位秒级时间戳 | 128位随机数
3. 约 136年
4. 无
5. 单秒内可生成2^128个ID
6.

UUID
1. 128位，标准36字符字符串（含“-”）；若以16进制存储，为32位字符长度
2. v4结构为：122位随机+6位版本标识
3. 无
4. 无
5. 无
6. v1基于时间戳+MAC地址+序列，v4基于高质量随机数生成，不保证有序，适合做唯一标识

NanoID / ShortID
1. 长度可自定义，常用为 21位Base62字符（约128位强度）
2. 随机数生成（可带时间戳，但大多只用随机）
3. 无
4. 无
5. 无
6. 基于高质量随机数，可选加入时间戳，适合短链接、邀请码等需要短ID的场景

"""
